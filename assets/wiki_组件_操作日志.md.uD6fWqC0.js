import{_ as t,c as r,o as a,ag as i}from"./chunks/framework.BgId8OS5.js";const f=JSON.parse('{"title":"操作日志","description":"","frontmatter":{"title":"操作日志","slug":"操作日志","sidebar_position":1},"headers":[],"relativePath":"wiki/组件/操作日志.md","filePath":"wiki/组件/操作日志.md"}'),s={name:"wiki/组件/操作日志.md"};function o(l,e,p,_,n,c){return a(),r("div",null,e[0]||(e[0]=[i('<h1 id="操作日志" tabindex="-1">操作日志 <a class="header-anchor" href="#操作日志" aria-label="Permalink to &quot;操作日志&quot;">​</a></h1><p>属性上加注解，解析属性由什么变成了什么。和easyexcel 的使用方式还挺像</p><p>func DiffField是为了记录该属性的时候，自定义记录内容,只有表达式里面写了_DIFF才会去diff两者不同，否则就是只有一个东西的变动，也就是null-&gt;变动【记录仅更新/或新增】，要么就是src-&gt;target[记录变动]</p><p>为什么要用栈，是因为，你可能service里面用了另一个service方法，然后呢，另一个service方法上也有注解</p><p>javers-spring-boot-starter-sql: 这个也用，作为最纯粹的【给个开关，原生支持开关】，然后starter也写，是基于它的</p><p>局限性：javers只能记录通过Repository进行数据变更记录，而且只能基于repository使用</p><p>所以咱们的组件只需要扩展javers，让他支持service层</p><ol><li>funcParse</li><li>context</li><li></li></ol>',8)]))}const u=t(s,[["render",o]]);export{f as __pageData,u as default};
